# Node Modules

Node modules are just js files. However, there are some important differences between Node modules and js files that run in the browser. Apart from the different APIs that are available, there is also a difference related to scope.

In a js file that runs in the browser, if you declare a variable outside of any function, you create a global variable/property. This does not happen in Node modules. Variables you declare outside of a function are local to the module and do not become a property of the global object. It is as if the content of Node modules are wrapped by an invisible iife.

It is also as if the invisible immediately-invoked function wrapping a module's contents has several arguments passed to it. One of these is `module`, an object representing the module. This object has a property named `exports` which starts out as an empty object. There is also a local variable named `exports` that refers to this object. If you want to make any data or function available to other modules that use your module, you must attach it to this object. `this` within a module refers to the same object as `exports`.

Note that if you want to replace a module's `exports` with a brand new object of your creation, you have to explicitly set `module.exports`. Merely setting `exports` to a new value will not change what other modules get when they use your module.

```js
module.exports = function() {
    console.log('This module is just a function.');
};
```

## `require`

For a module to use another module, it must first include or import it with a call to the global function `require`.

```js
var url = require('url');
```

In the example above, the `url` variable is now equal to the `exports` object of the url module.

Once a module is required by another module, all other calls to require it return the exact same object that the first one did. Every module is initialized only once.

```js
var url = require('url');
require('url') == url; //true
```

It is possible for Node modules to have _circular dependencies_. If module A requires module B and module B requires module A, B will not be able to access everything that A attaches to its `exports` object if A is still in the process of initializing. In this situation, A will appear to B to be an empty object.

<a href="https://nodejs.org/api/">Modules that come with Node</a> can be included simply by passing their name to `require`. Modules that you install into your project with `npm install` can also be required in this manner (these are placed in a directory named `node_modules` in the root of your project). You can set an environment variable named `NODE_PATH` if you wish to access modules in your project directories in this manner, or you can include a path in the string you pass to `require`.

```js
var http = require('http'); //require the built-in http module
var handlebars = require('handlebars'); //require the handlebars module installed from npm
var myModule = require('./my-module'); //require my-module from the current directory
```

Every node process has a main module. This is the module whose filename was typed after `node ` on the command line when the process was started. If for some reason you want to access this module, you can with `require.main`.

## The `process` module

The `process` module is special in that you do not have to require it to use it - it is available as a global.

`process` provides information about the current Node process that is running. For example, its `argv` property gives you access to the arguments that were used to start the process and its `env` property gives you access to the current environment variables.

## Exercise

Complete <a href="../wk5_url_describe">this exercise</a> involving `process.argv` and the `url` and `querystring` modules.
